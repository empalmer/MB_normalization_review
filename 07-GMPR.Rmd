# GMPR

A recent extension of the RLE DESeq method is the Geometric mean of Pairwise ratios (GMPR) approach [@chen2018]. This method reverses the steps of RLE, and instead calculates the median count ratio of the non-zero counts between pairs of samples as although only a small number of taxa are likely to be shared for every sample, it is more likely that there are many shared taxa between pairs. It then uses the pairwise results to calculate the size factor for each sample. This method has slow computation, but is robust to differential and outlier taxa. It addresses sparsity, but not composition. The size factors can be inputted to DESeq and a VST transformation applied additionally. It is a newer method, and has unfortunately not been included in many benchmarking studies, although initial results show it to be more powerful than DESeq, not surprisingly, as it uses more data, as zero counts do not need to be discarded. It assumes there is a large invariant portion of the count data, similar to other methods.

## GMPR Implementation

Consider the following zero-inflated dataset. Notice that there are no taxa that are present in every sample. 

```{r}
sample1 <- c(132, 0, 0, 23, 71, 0)
sample2 <- c(103, 48, 2, 0, 80, 96)
sample3 <- c(0, 74, 0, 35, 0, 82)
taxa <- paste("Taxon", 1:6)

sampling_depth <- c(sum(sample1), sum(sample2), sum(sample3))

tibble(taxa, sample1, sample2, sample3) %>%
    knitr::kable(
        col.names = c("Taxa", "Sample 1", "Sample2", "Sample 3"),
        caption =  "Example dataset - Raw Counts", 
        format = "html"
    ) 
```

The first step in GMPR normalization is to calculate the pairwise median count ratio between samples. We first calculate the scaling factor for sample 1. The pairwise comparisons we need to make are between sample 1 and sample 2 as well as sample 1 and sample 3. For both pairs, we calculate the ratio of the counts of taxa that the pair shares. Between sample 1 and sample 2, the shared taxa are 1 and 5. Between sample 1 and sample 3, taxon 4 is the only one shared. 

```{r}
r12 <- c("132/103", NA, NA, NA, "71/80", NA)
r13 <- c(NA, NA, NA, "23/35", NA, NA)
options(knitr.kable.NA = '')
tibble(taxa, sample1, sample2, sample3, r12, r13) %>%
    knitr::kable(
        col.names = c("Taxa", "Sample 1", "Sample2", "Sample 3", "Count ratio between 1 and 2", "Count ratio between 1 and 3"),
        caption =  "Example dataset - Raw Counts", 
        format = "html"
    ) 
```

Then we calculate the median of the ratios between each pair. Between sample 1 and 2, the two ratios between shared taxa are (132/103, 71/80). Then the median of those is 1.085. Between sample 1 and 3, there is only one shared taxa, so the median is 0.657. 

Finally to find the scaling factor for sample 1, we calculate the geometric mean of the two medians of the pairwise shared taxa ratios. In this case it is the geometric mean of 1.085 and 0.657, which equals 0.844. This is the scaling factor for sample 1. 
We now repeat this process to find the scaling factor for sample 1 and sample 3. 


The following provides the R code to implement GMPR normalization in R. We can additionally specify the number of taxa that should be shared between paired samples as well as the minimum count labeled as nonzero. The default values are 4 and 2 respectively.

```{r, gmpr-implementation}
m <- t(matrix(c(sample1, sample2, sample3), nrow = 6))
norm_GMPR <- function(ps, intersect_no = 4, min_ct = 2){
  require(GMPR, quietly = T)
    # Convert data to correct format for GMPR function 
    otu <- as(otu_table(ps), "matrix")
    if(taxa_are_rows(ps)){otu <- t(otu)}
    otu_df = as.data.frame(otu)
    otu.tab <- matrix(otu, ncol = ncol(otu))
    # calculate scaling factor
    # OTU matrix must be a data frame where OTUs are arranged in columns and samples as rows
    gmpr.size.factor <- GMPR::GMPR(OTUmatrix = otu_df,
                                   intersect_no = intersect_no,
                                   min_ct = min_ct)
    # normalize
    otu.tab.norm <- t(otu / (gmpr.size.factor))
    # convert back to PS
    otu_ps <- otu_table(otu.tab.norm, taxa_are_rows = T)
    sam <- access(ps, "sam_data")
    sam$scaling_factor <- gmpr.size.factor
    tax <- access(ps, "tax_table")
    phy <- access(ps, "phy_tree")
    ps_GMPR <- phyloseq(otu_ps,sam,tax,phy)
    return(ps_GMPR)
}

```

## Global Patterns GMPR

```{r}
# Normalize
gp_gmpr <- norm_GMPR(gp_raw)

# Compare to other methods like before
plot_norm_changes(gp_gmpr, gp_raw,
                  x_lab = "GMPR", y_lab = "Raw Counts",
                  title = "GMPR normalization vs Raw Counts")
plot_norm_changes(gp_gmpr, gp_tss,
                  x_lab = "TSS", y_lab = "GMPR",
                  title = "TSS vs GMPR")
plot_norm_changes(gp_gmpr, gp_deseq_rle,
                  x_lab = "DESeq", y_lab = "GMPR",
                  title = "DESeq vs GMPR" )
```




